#!/usr/bin/env bash

# host wrapper for a container-hosted sdk_debug_shell.py

# locate our own directory
MY_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)

# the SIF should be adjacent to us
shopt -s nullglob
SIFS=("$MY_DIR"/*.sif)
shopt -u nullglob

if (( ${#SIFS[@]} <= 0)); then
  printf "\033[31m[ERROR]\033[0m SIF not found\n" >&2
  exit 1
fi
if (( ${#SIFS[@]} > 1)); then
  printf "\033[33m[WARNING]\033[0m Multiple SIFs found: %s\n" "${SIFS[*]}" >&2
fi
printf "\033[34m[INFO]\033[0m Using SIF: %s\n" "${SIFS[0]}" >&2

if ! command -v singularity &>/dev/null; then
  printf "\033[31m[ERROR]\033[0m singularity not in \$PATH\n" >&2
  exit 1
fi

# The user can mount couple of folders when launching a
# singularity container via
#    CSL_IMPORT_PATH=<path 1>:<path 2>
# where the <path xxx> must be specified by "realpath <xxx>".
#
# The script parse CSL_IMPORT_PATH and generate a variable
#    bind_list= --bind=<path 1> --bind=<path 2>
#
# Example: to run csl-extras-xxx/benchmarks/SdkRuntime, the
# user must specify
#  CSL_IMPORT_PATH=<path of csl-extras-xxx/benchmarks/SdkRuntime>
bind_list=()
if [[ -n $CSL_IMPORT_PATH ]]; then
    printf "\033[34m[INFO]\033[0m User specified CSL_IMPORT_PATH=$CSL_IMPORT_PATH\n" >&2
else
    printf "\033[34m[INFO]\033[0m CSL_IMPORT_PATH is not set\n" >&2
fi
printf "\033[34m[INFO]\033[0m CSL_IMPORT_PATH accepts colon separated list of paths generated by 'realpath <path>'\n" >&2
for i in $(echo $CSL_IMPORT_PATH | tr ":" "\n")
do
  printf "\033[34m[INFO]\033[0m Bind path $i\n" >&2
  bind_list="$bind_list --bind=$i"
done
if [ -n "${bind_list}" ]; then
  printf "\033[34m[INFO]\033[0m Commands of user-specified mount paths: $bind_list\n" >&2
fi

PWD=$(realpath $(pwd))

# - mount /tmp first in case PWD=/tmp/xxx
# - mount TMPDIR in case some third party tool relies on TMPDIR to create temporary files
exec singularity exec ${bind_list} --bind=${TMPDIR} --bind=${TMPDIR:-/tmp}:/tmp --bind=${PWD} "--bind=${IMPORT_PATH}" -C \
  "--pwd=${PWD}" -- "${SIFS[0]}" \
  sdk_debug_shell "$@"
